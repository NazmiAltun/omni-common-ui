{"version":3,"sources":["containers/PermissionHandler/spec.jsx"],"names":["describe","beforeEach","merge","featureLogin","test","wrapper","expect","find","toHaveLength","contains","toBe","html","toThrowError","canAccess","jest","fn","props","permissionChecks","havePrivilegesLoaded","toHaveBeenCalledWith","mockReturnValue","toHaveBeenCalled","not","permissionChecks1","permissionChecks2","routes","result","toEqual"],"mappings":"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","file":"spec.js","sourcesContent":["import React from 'react';\nimport { shallow } from 'enzyme';\nimport Config from 'domain/Config';\nimport { PermissionHandler, mapStateToProps } from './';\n\ndescribe('component', () => {\n  describe('when featureLogin is not true', () => {\n    beforeEach(() => {\n      Config.merge({ featureLogin: false });\n    });\n\n    test('renders its children', () => {\n      const wrapper = shallow(<PermissionHandler><div id=\"inner\" /></PermissionHandler>);\n      expect(wrapper.find('#inner')).toHaveLength(1);\n    });\n  });\n\n  describe('when featureLogin is true', () => {\n    beforeEach(() => {\n      Config.merge({ featureLogin: true });\n    });\n\n    test('does nothing if no route is provided', () => {\n      const wrapper = shallow(<PermissionHandler havePrivilegesLoaded={() => true}>\n        <div id=\"inner\" />\n      </PermissionHandler>);\n      expect(wrapper.contains(<div id=\"inner\" />)).toBe(true);\n    });\n\n    test('renders nothing if privileges have not been loaded', () => {\n      const wrapper = shallow(<PermissionHandler havePrivilegesLoaded={() => false}>\n        <div id=\"inner\" />\n      </PermissionHandler>);\n      expect(wrapper.html()).toBe(null);\n    });\n\n    test('throws if permissionChecks.canAccess is not a function', () => {\n      expect(() => shallow(<PermissionHandler permissionChecks={[{}]}\n          havePrivilegesLoaded={() => true} />)).toThrowError();\n    });\n\n    test('calls permissionChecks.canAccess passing all props if it is a function', () => {\n      const canAccess = jest.fn();\n      const props = { permissionChecks: [{ canAccess }], havePrivilegesLoaded: () => true };\n      shallow(<PermissionHandler {...props} />);\n      expect(canAccess).toHaveBeenCalledWith(props);\n    });\n\n    test('calls canAccess() for all routes until one returns false', () => {\n      const props = {\n        permissionChecks: [\n          { canAccess: jest.fn().mockReturnValue(true) },\n          { canAccess: jest.fn().mockReturnValue(false) },\n          { canAccess: jest.fn().mockReturnValue(false) },\n        ],\n        havePrivilegesLoaded: () => true,\n      };\n      shallow(<PermissionHandler {...props} />);\n      expect(props.permissionChecks[0].canAccess).toHaveBeenCalled();\n      expect(props.permissionChecks[1].canAccess).toHaveBeenCalled();\n      expect(props.permissionChecks[2].canAccess).not.toHaveBeenCalled();\n    });\n  });\n});\n\ndescribe('mapStateToProps()', () => {\n  beforeEach(() => {\n    Config.merge({ featureLogin: true });\n  });\n\n  test('returns permissionChecks as an array with all routes that have a canAccess()', () => {\n    const permissionChecks1 = { canAccess: () => {} };\n    const permissionChecks2 = { canAccess: () => {} };\n    const routes = [{}, permissionChecks1, {}, permissionChecks2];\n    const result = mapStateToProps(null, { routes });\n    expect(result.permissionChecks).toEqual([permissionChecks1, permissionChecks2]);\n  });\n\n  test('returns permissionChecks as an array with one route ' +\n      'if there is only one that has a canAccess()', () => {\n    const permissionChecks1 = { canAccess: () => {} };\n    const routes = [{}, permissionChecks1, {}];\n    const result = mapStateToProps(null, { routes });\n    expect(result.permissionChecks).toEqual([permissionChecks1]);\n  });\n\n  test('returns permissionChecks as an empty array if no route has canAccess()', () => {\n    expect(mapStateToProps(null, { routes: [{}, {}, {}] }).permissionChecks).toEqual([]);\n  });\n});\n"]}