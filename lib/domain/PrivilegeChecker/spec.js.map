{"version":3,"sources":["domain/PrivilegeChecker/spec.js"],"names":["state","beforeEach","privileges","items","merge","featureLogin","test","expect","hasPrivilege","toBe","toThrow","describe"],"mappings":";;AAAA;;AACA;;;;AACA;;;;;;AAEA,IAAIA,cAAJ;;AAEAC,WAAW,YAAM;AACfD,UAAQ,mBAAQ,EAAEE,YAAY,EAAEC,OAAO,oBAAS,CAAC,KAAD,EAAQ,KAAR,EAAe,YAAf,CAAT,CAAT,EAAd,EAAR,CAAR;AACA,mBAAOC,KAAP,CAAa,EAAEC,cAAc,IAAhB,EAAb;AACD,CAHD;;AAKAC,KAAK,gDAAL,EAAuD,YAAM;AAC3DC,SAAO,WAAiBC,YAAjB,CAA8BR,KAA9B,EAAqC,CAArC,CAAP,EAAgDS,IAAhD,CAAqD,KAArD;AACD,CAFD;;AAIAH,KAAK,mEAAL,EAA0E,YAAM;AAC9EC,SAAO;AAAA,WAAM,WAAiBC,YAAjB,CAA8B,EAA9B,EAAkC,KAAlC,CAAN;AAAA,GAAP,EAAuDE,OAAvD;AACD,CAFD;;AAIAJ,KAAK,yCAAL,EAAgD,YAAM;AACpDC,SAAO,WAAiBC,YAAjB,CAA8B,qBAA9B,EAAqC,KAArC,CAAP,EAAoDC,IAApD,CAAyD,KAAzD;AACAF,SAAO,WAAiBC,YAAjB,CAA8B,oBAAI,EAAEN,YAAY,IAAd,EAAJ,CAA9B,EAAyD,KAAzD,CAAP,EAAwEO,IAAxE,CAA6E,KAA7E;AACAF,SAAO,WAAiBC,YAAjB,CAA8B,oBAAI,EAAEN,YAAY,qBAAd,EAAJ,CAA9B,EAA0D,KAA1D,CAAP,EAAyEO,IAAzE,CAA8E,KAA9E;AACD,CAJD;;AAMAH,KAAK,8DAAL,EAAqE,YAAM;AACzEC,SAAO,WAAiBC,YAAjB,CAA8BR,KAA9B,EAAqC,KAArC,CAAP,EAAoDS,IAApD,CAAyD,IAAzD;AACD,CAFD;;AAIAH,KAAK,sEAAL,EAA6E,YAAM;AACjFC,SAAO,WAAiBC,YAAjB,CAA8BR,KAA9B,EAAqC,KAArC,CAAP,EAAoDS,IAApD,CAAyD,IAAzD;AACD,CAFD;;AAIAH,KAAK,qFAAL,EAA4F,YAAM;AAChGC,SAAO,WAAiBC,YAAjB,CAA8BR,KAA9B,EAAqC,KAArC,CAAP,EAAoDS,IAApD,CAAyD,IAAzD;AACD,CAFD;;AAIAE,SAAS,+BAAT,EAA0C,YAAM;AAC9CV,aAAW,YAAM;AACf,qBAAOG,KAAP,CAAa,EAAEC,cAAc,KAAhB,EAAb;AACD,GAFD;;AAIAC,OAAK,cAAL,EAAqB,YAAM;AACzBC,WAAO,WAAiBC,YAAjB,EAAP,EAAwCC,IAAxC,CAA6C,IAA7C;AACD,GAFD;AAGD,CARD","file":"spec.js","sourcesContent":["import { Map, List } from 'immutable';\nimport Config from 'domain/Config';\nimport PrivilegeChecker from './';\n\nlet state;\n\nbeforeEach(() => {\n  state = new Map({ privileges: { items: new List(['pr1', 'pr2', 'PREFIX_pr3']) } });\n  Config.merge({ featureLogin: true });\n});\n\ntest('returns false if the privilege is not a string', () => {\n  expect(PrivilegeChecker.hasPrivilege(state, 1)).toBe(false);\n});\n\ntest('throws if something else rather than a Map is provided as a state', () => {\n  expect(() => PrivilegeChecker.hasPrivilege({}, 'pr1')).toThrow();\n});\n\ntest('returns false if the state is malformed', () => {\n  expect(PrivilegeChecker.hasPrivilege(Map(), 'pr1')).toBe(false);\n  expect(PrivilegeChecker.hasPrivilege(Map({ privileges: null }), 'pr1')).toBe(false);\n  expect(PrivilegeChecker.hasPrivilege(Map({ privileges: Map() }), 'pr1')).toBe(false);\n});\n\ntest('returns true if the privilege is found in the privilege list', () => {\n  expect(PrivilegeChecker.hasPrivilege(state, 'pr1')).toBe(true);\n});\n\ntest('returns true even if the privilege is provided with a different case', () => {\n  expect(PrivilegeChecker.hasPrivilege(state, 'PR1')).toBe(true);\n});\n\ntest('returns true if there is a privilege in the list that ends with the provided string', () => {\n  expect(PrivilegeChecker.hasPrivilege(state, 'pr3')).toBe(true);\n});\n\ndescribe('when featureLogin is not true', () => {\n  beforeEach(() => {\n    Config.merge({ featureLogin: false });\n  });\n\n  test('returns true', () => {\n    expect(PrivilegeChecker.hasPrivilege()).toBe(true);\n  });\n});\n"]}